local licenseNotice = [[This installation script is createt by MisterNoNameLPs OC project exporter v1.0.5
<https://github.com/MisterNoNameLP/ocCraft/blob/master/src/debug/export.lua>.

This installer DO NOT give ANY WARRANTY for stored/installed data.
All stored/installed data are third party content i am not responsible for. 

  export Copyright (C) 2019 MisterNoNameLP.
  
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]
local data = {["//data/libs/LIP.lua"] = "--[[\13\n\9Copyright (c) 2012 Carreras Nicolas\13\n\9\13\n\9Permission is hereby granted, free of charge, to any person obtaining a copy\13\n\9of this software and associated documentation files (the \"Software\"), to deal\13\n\9in the Software without restriction, including without limitation the rights\13\n\9to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\n\9copies of the Software, and to permit persons to whom the Software is\13\n\9furnished to do so, subject to the following conditions:\13\n\9\13\n\9The above copyright notice and this permission notice shall be included in all\13\n\9copies or substantial portions of the Software.\13\n\9\13\n\9THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\n\9IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\n\9FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\n\9AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\n\9LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\n\9OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\n\9SOFTWARE.\13\n--]]\13\n--- Lua INI Parser.\13\n-- It has never been that simple to use INI files with Lua.\13\n--@author Dynodzzo\13\n\13\nlocal LIP = {};\13\n\13\n--- Returns a table containing all the data from the INI file.\13\n--@param fileName The name of the INI file to parse. [string]\13\n--@return The table containing all data from the INI file. [table]\13\nfunction LIP.load(fileName)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9local file = assert(io.open(fileName, 'r'), 'Error loading file : ' .. fileName);\13\n\9local data = {};\13\n\9local section;\13\n\9for line in file:lines() do\13\n\9\9local tempSection = line:match('^%[([^%[%]]+)%]$');\13\n\9\9if(tempSection)then\13\n\9\9\9section = tonumber(tempSection) and tonumber(tempSection) or tempSection;\13\n\9\9\9data[section] = data[section] or {};\13\n\9\9end\13\n\9\9local param, value = line:match('^([%w|_]+)%s-=%s-(.+)$');\13\n\9\9if(param and value ~= nil)then\13\n\9\9\9if(tonumber(value))then\13\n\9\9\9\9value = tonumber(value);\13\n\9\9\9elseif(value == 'true')then\13\n\9\9\9\9value = true;\13\n\9\9\9elseif(value == 'false')then\13\n\9\9\9\9value = false;\13\n\9\9\9end\13\n\9\9\9if(tonumber(param))then\13\n\9\9\9\9param = tonumber(param);\13\n\9\9\9end\13\n\9\9\9data[section][param] = value;\13\n\9\9end\13\n\9end\13\n\9file:close();\13\n\9return data;\13\nend\13\n\13\n--- Saves all the data from a table to an INI file.\13\n--@param fileName The name of the INI file to fill. [string]\13\n--@param data The table containing all the data to store. [table]\13\nfunction LIP.save(fileName, data)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9assert(type(data) == 'table', 'Parameter \"data\" must be a table.');\13\n\9local file = assert(io.open(fileName, 'w+b'), 'Error loading file :' .. fileName);\13\n\9local contents = '';\13\n\9for section, param in pairs(data) do\13\n\9\9contents = contents .. ('[%s]\\n'):format(section);\13\n\9\9for key, value in pairs(param) do\13\n\9\9\9contents = contents .. ('%s=%s\\n'):format(key, tostring(value));\13\n\9\9end\13\n\9\9contents = contents .. '\\n';\13\n\9end\13\n\9file:write(contents);\13\n\9file:close();\13\nend\13\n\13\nreturn LIP;",["//data/libs/dbgpu_api.lua"] = "--[[\13\n\9!The api is not complete yet!\13\n\9\13\n\9This is a little api to make the DoubleBuffering libarry by IgorTimofeev acting like a normal OC gpu.\13\n\9\13\n\9With the default settings it is acting (nearly) exacly like a normal OC gpu (so its basicly useless).\13\n\9To get the full effect of the DoubleBuffering you should deactivate directDraw but then you manually need to use the drawChanges function.\13\n\9\13\n\9DoubleBuffering source: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n\9DoubleBuffering Copyright (c) 2018 Igor Timofeev\13\n\9\13\n\9dbgpu_api Copyright (c) 2019 NosPo Studio\13\n\9\13\n    dbgpu_api is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    dbgpu_api is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with dbgpu_api.  If not, see <https://www.gnu.org/licenses/>.\9\13\n]]\13\n\13\nlocal version = \"v0.3.1\"\13\n\13\nlocal args = ...\13\nlocal path = args.path or \"\"\13\n\13\nlocal buffer = require(path .. \"libs/DoubleBuffering\")\13\nlocal gpu = require(\"component\").gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal ut = require(\"libs/UT\")\13\n\13\nlocal lastBackground = gpu.getBackground()\13\nlocal lastForeground = gpu.getForeground()\13\n\13\nlocal currentVBuffer = 0\13\nlocal cpuBuffers = {}\13\n\13\nif gpu.getActiveBuffer then\13\n\9currentVBuffer = gpu.getActiveBuffer()\13\nend\13\n\13\nlocal function flushBuffer(id, w, h)\13\n\9cpuBuffers[id] = {\13\n\9\9drawLimit = {1, 1, w, h},\13\n\9\9current = {{}, {}, {}, w, h},\13\n\9\9new = {{}, {}, {}, w, h},\13\n\9}\13\n\9\13\n\9for y = 1, h do\13\n\9\9for x = 1, w do\13\n\9\9\9table.insert(cpuBuffers[id].current[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].current[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].current[3], \" \")\13\n\9\13\n\9\9\9table.insert(cpuBuffers[id].new[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].new[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].new[3], \" \")\13\n\9\9end\13\n\9end\13\nend\13\nlocal function setBuffer(id)\13\n\9cpuBuffers[currentVBuffer].drawLimit = {buffer.getDrawLimit()}\13\n\9\13\n\9buffer.setCurrentFrameTables(cpuBuffers[id].current[1], cpuBuffers[id].current[2], cpuBuffers[id].current[3], cpuBuffers[id].current[4], cpuBuffers[id].current[5])\13\n\9buffer.setNewFrameTables(cpuBuffers[id].new[1], cpuBuffers[id].new[2], cpuBuffers[id].new[3], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9buffer.setDrawLimit(cpuBuffers[id].drawLimit[1], cpuBuffers[id].drawLimit[2], cpuBuffers[id].drawLimit[3], cpuBuffers[id].drawLimit[4])\13\n\9\13\n\9currentVBuffer = id\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function getSubFunc(s)\13\n\9if #s ~= unicode.len(s) then\13\n\9\9return unicode.sub\13\n\9else\13\n\9\9return string.sub\13\n\9end\13\nend\13\n\13\nlocal dbgpu = {\13\n\9directDraw = parseArgs(args.directDraw, true),\13\n\9forceDraw = parseArgs(args.forceDraw, false),\13\n\9rawCopy = parseArgs(args.rawCopy, false),\13\n\9actualRawCopy = parseArgs(args.actualRawCopy, args.rawCopy),\13\n\9version = version,\13\n\9buffer = buffer,\13\n}\13\n\13\nlocal function draw()\13\n\9if dbgpu.directDraw then\13\n\9\9buffer.drawChanges(dbgpu.forceDraw)\13\n\9end\13\nend\13\n\13\nfunction dbgpu.set(x, y, s, v)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9if v then\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x, y +i -1, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9else\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x +i -1, y, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9end\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.fill(x, y, sx, sy, s)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9sx = math.floor(sx)\13\n\9sy = math.floor(sy)\13\n\9s = sub(s, 0, 1)\13\n\9buffer.drawRectangle(x, y, sx, sy, lastBackground, lastForeground, s)\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.copy(x, y, sx, sy, tx, ty)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9tx = math.floor(tx)\13\n\9ty = math.floor(ty)\13\n\9\13\n\9if sx * sy > 3200 then\13\n\9\9buffer.directCopy(x, y, sx, sy, tx +x, ty +y, dbgpu.rawCopy)\13\n\9else\13\n\9\9local data, rawData = buffer.copy(x, y, sx, sy, dbgpu.rawCopy)\13\n\9\9buffer.paste(tx +x, ty +y, data, rawData)\13\n\9end\13\n\9\13\n\9if dbgpu.rawCopy and dbgpu.actualRawCopy then\9\9\13\n\9\9gpu.copy(x, y, sx, sy, tx, ty)\13\n\9end\9\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.getBackground()\13\n\9return lastBackground\13\nend\13\nfunction dbgpu.getForeground()\13\n\9return lastForeground\13\nend\13\n\13\nfunction dbgpu.setBackground(c)\13\n\9lastBackground = c\13\n\9--return gpu.setBackground(c)\13\nend\13\nfunction dbgpu.setForeground(c)\13\n\9lastForeground = c\13\n\9--return gpu.setForeground(c)\13\nend\13\n\13\nfunction dbgpu.setResolution(x, y)\13\n\9buffer.setResolution(x, y)\13\nend\13\nfunction dbgpu.getResolution()\13\n\9return buffer.getResolution()\13\nend\13\n\13\nfunction dbgpu.drawChanges(f)\13\n\9buffer.drawChanges(f)\13\nend\13\n\13\nfunction dbgpu.drawImage(x, y, image)\13\n\9buffer.drawImage(x, y, image)\13\nend\13\n\13\nfunction dbgpu.getActiveBuffer()\13\n\9return currentVBuffer\13\nend\13\nfunction dbgpu.setActiveBuffer(id, force)\13\n\9if id == currentVBuffer or force then\13\n\9\9return false, \"Buffer is set already\"\13\n\9else\13\n\9\9local suc = gpu.setActiveBuffer(id)\13\n\9\9\13\n\9\9if suc ~= nil then\13\n\9\9\9\13\n\9\9\9setBuffer(id)\13\n\9\9\9\13\n\9\9\9do\13\n\9\9\9\9local b = buffer.getNewFrameTables()\13\n\9\9\9\9local b2 = cpuBuffers[id].new[1]\13\n\9\9\9\9\13\n\9\9\9\9--print(b, b2, b == b2)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9--print(\"T\", id)\13\n\9\9\9--print(cpuBuffers[0], cpuBuffers[1])\13\n\9\9\9--print(#cpuBuffers[0].new[1], #cpuBuffers[1].new[1], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9\9end\13\n\9\9return id\13\n\9end\13\nend\13\n--debug/dbgpuVBufferTest.lua > logs/test.log\13\nfunction dbgpu.allocateBuffer(w, h)\13\n\9local id = gpu.allocateBuffer(w, h)\13\n\9if type(id) == \"number\" then\13\n\9\9flushBuffer(id, w, h)\13\n\9end\13\n\9return id\13\nend\13\nfunction dbgpu.freeBuffer(id)\13\n\9cpuBuffers[id] = nil\13\n\9return gpu.freeBuffer(id)\13\nend\13\nfunction dbgpu.bitblt(...)\13\n\9return gpu.bitblt(...)\13\nend\13\nfunction dbgpu.freeAllBuffers()\13\n\9currentVBuffer = 0\13\n\9return gpu.freeAllBuffers()\13\nend\13\n\13\n--===== init =====--\13\nlocal resX, resY = gpu.getResolution()\13\nflushBuffer(0, resX, resY)\13\nsetBuffer(0)\13\n\13\n--dbgpu = setmetatable(dbgpu, {__index = gpu})\13\n--maxResolution\13\n--maxResolution\13\n\13\nreturn dbgpu",["//data/libs/color.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are possibly made some changes if needed to fit in to the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/Color>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\ncolor Copyright (c) 2018 \13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\n\13\nlocal computer = require(\"computer\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal palette = {0x000000, 0x000040, 0x000080, 0x0000BF, 0x0000FF, 0x002400, 0x002440, 0x002480, 0x0024BF, 0x0024FF, 0x004900, 0x004940, 0x004980, 0x0049BF, 0x0049FF, 0x006D00, 0x006D40, 0x006D80, 0x006DBF, 0x006DFF, 0x009200, 0x009240, 0x009280, 0x0092BF, 0x0092FF, 0x00B600, 0x00B640, 0x00B680, 0x00B6BF, 0x00B6FF, 0x00DB00, 0x00DB40, 0x00DB80, 0x00DBBF, 0x00DBFF, 0x00FF00, 0x00FF40, 0x00FF80, 0x00FFBF, 0x00FFFF, 0x0F0F0F, 0x1E1E1E, 0x2D2D2D, 0x330000, 0x330040, 0x330080, 0x3300BF, 0x3300FF, 0x332400, 0x332440, 0x332480, 0x3324BF, 0x3324FF, 0x334900, 0x334940, 0x334980, 0x3349BF, 0x3349FF, 0x336D00, 0x336D40, 0x336D80, 0x336DBF, 0x336DFF, 0x339200, 0x339240, 0x339280, 0x3392BF, 0x3392FF, 0x33B600, 0x33B640, 0x33B680, 0x33B6BF, 0x33B6FF, 0x33DB00, 0x33DB40, 0x33DB80, 0x33DBBF, 0x33DBFF, 0x33FF00, 0x33FF40, 0x33FF80, 0x33FFBF, 0x33FFFF, 0x3C3C3C, 0x4B4B4B, 0x5A5A5A, 0x660000, 0x660040, 0x660080, 0x6600BF, 0x6600FF, 0x662400, 0x662440, 0x662480, 0x6624BF, 0x6624FF, 0x664900, 0x664940, 0x664980, 0x6649BF, 0x6649FF, 0x666D00, 0x666D40, 0x666D80, 0x666DBF, 0x666DFF, 0x669200, 0x669240, 0x669280, 0x6692BF, 0x6692FF, 0x66B600, 0x66B640, 0x66B680, 0x66B6BF, 0x66B6FF, 0x66DB00, 0x66DB40, 0x66DB80, 0x66DBBF, 0x66DBFF, 0x66FF00, 0x66FF40, 0x66FF80, 0x66FFBF, 0x66FFFF, 0x696969, 0x787878, 0x878787, 0x969696, 0x990000, 0x990040, 0x990080, 0x9900BF, 0x9900FF, 0x992400, 0x992440, 0x992480, 0x9924BF, 0x9924FF, 0x994900, 0x994940, 0x994980, 0x9949BF, 0x9949FF, 0x996D00, 0x996D40, 0x996D80, 0x996DBF, 0x996DFF, 0x999200, 0x999240, 0x999280, 0x9992BF, 0x9992FF, 0x99B600, 0x99B640, 0x99B680, 0x99B6BF, 0x99B6FF, 0x99DB00, 0x99DB40, 0x99DB80, 0x99DBBF, 0x99DBFF, 0x99FF00, 0x99FF40, 0x99FF80, 0x99FFBF, 0x99FFFF, 0xA5A5A5, 0xB4B4B4, 0xC3C3C3, 0xCC0000, 0xCC0040, 0xCC0080, 0xCC00BF, 0xCC00FF, 0xCC2400, 0xCC2440, 0xCC2480, 0xCC24BF, 0xCC24FF, 0xCC4900, 0xCC4940, 0xCC4980, 0xCC49BF, 0xCC49FF, 0xCC6D00, 0xCC6D40, 0xCC6D80, 0xCC6DBF, 0xCC6DFF, 0xCC9200, 0xCC9240, 0xCC9280, 0xCC92BF, 0xCC92FF, 0xCCB600, 0xCCB640, 0xCCB680, 0xCCB6BF, 0xCCB6FF, 0xCCDB00, 0xCCDB40, 0xCCDB80, 0xCCDBBF, 0xCCDBFF, 0xCCFF00, 0xCCFF40, 0xCCFF80, 0xCCFFBF, 0xCCFFFF, 0xD2D2D2, 0xE1E1E1, 0xF0F0F0, 0xFF0000, 0xFF0040, 0xFF0080, 0xFF00BF, 0xFF00FF, 0xFF2400, 0xFF2440, 0xFF2480, 0xFF24BF, 0xFF24FF, 0xFF4900, 0xFF4940, 0xFF4980, 0xFF49BF, 0xFF49FF, 0xFF6D00, 0xFF6D40, 0xFF6D80, 0xFF6DBF, 0xFF6DFF, 0xFF9200, 0xFF9240, 0xFF9280, 0xFF92BF, 0xFF92FF, 0xFFB600, 0xFFB640, 0xFFB680, 0xFFB6BF, 0xFFB6FF, 0xFFDB00, 0xFFDB40, 0xFFDB80, 0xFFDBBF, 0xFFDBFF, 0xFFFF00, 0xFFFF40, 0xFFFF80, 0xFFFFBF, 0xFFFFFF}\13\nlocal mathFloor, mathMax, mathMin, mathModf = math.floor, math.max, math.min, math.modf\13\nlocal integerToRGB, RGBToInteger, blend, transition, to8Bit\13\n\13\nlocal color = {}\13\n\13\n--------------------------------------------------------------------------------\13\n\13\n-- Optimized Lua 5.3 bitwise support\13\nif computer.getArchitecture and computer.getArchitecture() == \"Lua 5.3\" then\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9return integerColor >> 16, integerColor >> 8 & 0xFF, integerColor & 0xFF\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r << 16 | g << 8 | b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9return\13\n\9\9\9\9\9((color2 >> 16) * invertedTransparency + (color1 >> 16) * transparency) // 1 << 16 |\13\n\9\9\9\9\9((color2 >> 8 & 0xFF) * invertedTransparency + (color1 >> 8 & 0xFF) * transparency) // 1 << 8 |\13\n\9\9\9\9\9((color2 & 0xFF) * invertedTransparency + (color1 & 0xFF) * transparency) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1, g1, b1 = color1 >> 16, color1 >> 8 & 0xFF, color1 & 0xFF\13\n\9\9\9\9return\13\n\9\9\9\9\9(r1 + ((color2 >> 16) - r1) * position) // 1 << 16 |\13\n\9\9\9\9\9(g1 + ((color2 >> 8 & 0xFF) - g1) * position) // 1 << 8 |\13\n\9\9\9\9\9(b1 + ((color2 & 0xFF) - b1) * position) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local r, g, b, closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = color24Bit >> 16, color24Bit >> 8 & 0xFF, color24Bit & 0xFF, mathHuge, 1\13\n\13\n\9\9\9\9for i = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[i]\13\n\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return i - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR, paletteG, paletteB = paletteColor >> 16, paletteColor >> 8 & 0xFF, paletteColor & 0xFF\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, i\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nelse\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9local r = integerColor / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (integerColor - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\13\n\9\9\9\9return r, g, integerColor - r * 65536 - g * 256\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r * 65536 + g * 256 + b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r2 * invertedTransparency + r1 * transparency,\13\n\9\9\9\9\9g2 * invertedTransparency + g1 * transparency,\13\n\9\9\9\9\9(color2 - r2 * 65536 - g2 * 256) * invertedTransparency + (color1 - r1 * 65536 - g1 * 256) * transparency\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\9\9\9\9local b1 = color1 - r1 * 65536 - g1 * 256\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r1 + (r2 - r1) * position,\13\n\9\9\9\9\9g1 + (g2 - g1) * position,\13\n\9\9\9\9\9b1 + (color2 - r2 * 65536 - g2 * 256 - b1) * position\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = mathHuge, 1\13\n\13\n\9\9\9\9local r = color24Bit / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (color24Bit - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\9\9\9\9local b = color24Bit - r * 65536 - g * 256\13\n\13\n\9\9\9\9for index = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[index]\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return index - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR = paletteColor / 65536\13\n\9\9\9\9\9\9paletteR = paletteR - paletteR % 1\13\n\9\9\9\9\9\9paletteG = (paletteColor - paletteR * 65536) / 256\13\n\9\9\9\9\9\9paletteG = paletteG - paletteG % 1\13\n\9\9\9\9\9\9paletteB = paletteColor - paletteR * 65536 - paletteG * 256\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, index\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function RGBToHSB(r, g, b)\13\n\9local max, min = mathMax(r, g, b), mathMin(r, g, b)\13\n\13\n\9if max == min then\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g >= b then\13\n\9\9return 60 * (g - b) / (max - min), max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g < b then\13\n\9\9return 60 * (g - b) / (max - min) + 360, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == g then\13\n\9\9return 60 * (b - r) / (max - min) + 120, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == b then\13\n\9\9return 60 * (r - g) / (max - min) + 240, max == 0 and 0 or (1 - min / max), max / 255\13\n\9else\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9end\13\nend\13\n\13\nlocal function HSBToRGB(h, s, b)\13\n\9local integer, fractional = mathModf(h / 60)\9\13\n\9local p, q, t = b * (1 - s), b * (1 - s * fractional), b * (1 - (1 - fractional) * s)\13\n\13\n\9if integer == 0 then\13\n\9\9return mathFloor(b * 255), mathFloor(t * 255), mathFloor(p * 255)\13\n\9elseif integer == 1 then\13\n\9\9return mathFloor(q * 255), mathFloor(b * 255), mathFloor(p * 255)\13\n\9elseif integer == 2 then\13\n\9\9return mathFloor(p * 255), mathFloor(b * 255), mathFloor(t * 255)\13\n\9elseif integer == 3 then\13\n\9\9return mathFloor(p * 255), mathFloor(q * 255), mathFloor(b * 255)\13\n\9elseif integer == 4 then\13\n\9\9return mathFloor(t * 255), mathFloor(p * 255), mathFloor(b * 255)\13\n\9else\13\n\9\9return mathFloor(b * 255), mathFloor(p * 255), mathFloor(q * 255)\13\n\9end\13\nend\13\n\13\nlocal function integerToHSB(integerColor)\13\n\9return RGBToHSB(integerToRGB(integerColor))\13\nend\13\n\13\nlocal function HSBToInteger(h, s, b)\13\n\9return RGBToInteger(HSBToRGB(h, s, b))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function to24Bit(color8Bit)\13\n\9return palette[color8Bit + 1]\13\nend\13\n\13\nlocal function optimize(color24Bit)\13\n\9return to24Bit(to8Bit(color24Bit))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nreturn {\13\n\9RGBToInteger = RGBToInteger,\13\n\9integerToRGB = integerToRGB,\13\n\9RGBToHSB = RGBToHSB,\13\n\9HSBToRGB = HSBToRGB,\13\n\9integerToHSB = integerToHSB,\13\n\9HSBToInteger = HSBToInteger,\13\n\9blend = blend,\13\n\9transition = transition,\13\n\9to8Bit = to8Bit,\13\n\9to24Bit = to24Bit,\13\n\9optimize = optimize,\13\n}",["//data/libs/DoubleBuffering.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are made some changes to provide the best possible performance in combination with the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (NosPo version) Copyright (c) 2019-2020 NosPo Studio\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\nlocal version = \"v0.8\" --NosPo version.\13\n\13\nlocal component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\nlocal color = require(\"libs/color\")\13\n--local image = require(\"libs/image\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal bufferWidth, bufferHeight\13\nlocal currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nlocal drawLimitX1, drawLimitX2, drawLimitY1, drawLimitY2\13\nlocal GPUProxy, GPUProxyGetResolution, GPUProxySetResolution, GPUProxyBind, GPUProxyGetBackground, GPUProxyGetForeground, GPUProxySetBackground, GPUProxySetForeground, GPUProxyGet, GPUProxySet, GPUProxyFill\13\n\13\nlocal mathCeil, mathFloor, mathModf, mathAbs = math.ceil, math.floor, math.modf, math.abs\13\nlocal tableInsert, tableConcat = table.insert, table.concat\13\nlocal colorBlend = color.blend\13\nlocal unicodeLen, unicodeSub = unicode.len, unicode.sub\13\n\13\nlocal drawAreas, nonDrawAreas = {}, {} --drawAreas == pixelWhiteList, nonDrawAreas == pixelBlackList\13\nlocal drawAreasAreWhitelist = true\13\nlocal drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nlocal bufferOnly = false\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getIndex(x, y)\13\n\9return bufferWidth * (y - 1) + x\13\nend\13\nlocal function getCoordinates(index)\13\n\9return index % bufferWidth, math.floor(index / bufferWidth) +1\13\nend\13\n\13\nlocal function getCurrentFrameTables()\13\n\9return currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function getNewFrameTables()\13\n\9return newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function setCurrentFrameTables(b, f, s, w, h)\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\nlocal function setNewFrameTables(b, f, s, w, h)\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\n\13\nlocal function setBufferOnly(b)\13\n\9bufferOnly = b\13\nend\13\nlocal function getBufferOnly()\13\n\9return bufferOnly\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function setDrawLimit(x1, y1, x2, y2)\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = x1, y1, x2, y2\13\nend\13\n\13\nlocal function resetDrawLimit()\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = 1, 1, bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getDrawLimit()\13\n\9return drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2\13\nend\13\n\13\nlocal function setDrawAreas(areas)\13\n\9drawAreas = areas\13\nend\13\nlocal function resetDrawAreas()\13\n\9drawAreas = {}\13\nend\13\nlocal function getDrawAreas()\13\n\9return drawAreas\13\nend\13\nlocal function setNonDrawAreas(areas)\13\n\9nonDrawAreas = areas\13\nend\13\nlocal function resetNonDrawAreas()\13\n\9nonDrawAreas = {}\13\nend\13\nlocal function getNonDrawAreas()\13\n\9return nonDrawAreas\13\nend\13\n\13\nlocal function setDrawAreaOffset(x, y)\13\n\9drawAreaOffsetX = x or drawAreaOffsetX\13\n\9drawAreaOffsetY = y or drawAreaOffsetY\13\n\9\13\nend\13\nlocal function getDrawAreaOffset()\13\n\9return drawAreaOffsetX, drawAreaOffsetY\13\nend\13\nlocal function resetDrawAreaOffset()\13\n\9drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nend\13\n\13\nlocal function isDrawable(x, y)\13\n\9local drawable = true\13\n\9\13\n\9if #drawAreas == 0 and #nonDrawAreas == 0 then\13\n\9\9--return true\13\n\9end\13\n\9\13\n\9for _, a in pairs(drawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = true\13\n\9\9\9break\13\n\9\9end\13\n\9\9drawable = false\13\n\9end\13\n\9for _, a in pairs(nonDrawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = false\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9return drawable\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function flush(width, height)\13\n\9if not width or not height then\13\n\9\9width, height = GPUProxyGetResolution()\13\n\9end\13\n\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = {}, {}, {}, {}, {}, {}\13\n\9bufferWidth = width\13\n\9bufferHeight = height\13\n\9resetDrawLimit()\13\n\13\n\9for y = 1, bufferHeight do\13\n\9\9for x = 1, bufferWidth do\13\n\9\9\9tableInsert(currentFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(currentFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(currentFrameSymbols, \" \")\13\n\13\n\9\9\9tableInsert(newFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(newFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(newFrameSymbols, \" \")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function setResolution(width, height)\13\n\9GPUProxySetResolution(width, height)\13\n\9flush(width, height)\13\nend\13\n\13\nlocal function getResolution()\13\n\9return bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getWidth()\13\n\9return bufferWidth\13\nend\13\n\13\nlocal function getHeight()\13\n\9return bufferHeight\13\nend\13\n\13\nlocal function bindScreen(...)\13\n\9GPUProxyBind(...)\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\nlocal function getGPUProxy()\13\n\9return GPUProxy\13\nend\13\n\13\nlocal function updateGPUProxyMethods()\13\n\9GPUProxyGet = GPUProxy.get\13\n\9GPUProxyGetResolution = GPUProxy.getResolution\13\n\9GPUProxyGetBackground = GPUProxy.getBackground\13\n\9GPUProxyGetForeground = GPUProxy.getForeground\13\n\13\n\9GPUProxySet = GPUProxy.set\13\n\9GPUProxySetResolution = GPUProxy.setResolution\13\n\9GPUProxySetBackground = GPUProxy.setBackground\13\n\9GPUProxySetForeground = GPUProxy.setForeground\13\n\13\n\9GPUProxyBind = GPUProxy.bind\13\n\9GPUProxyFill = GPUProxy.fill\13\nend\13\n\13\nlocal function bindGPU(address)\13\n\9GPUProxy = component.proxy(address)\13\n\9updateGPUProxyMethods()\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function rawSet(index, background, foreground, symbol)\13\n\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9if bufferOnly then\13\n\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9end\13\nend\13\n\13\nlocal function rawGet(index)\13\n\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\nend\13\n\13\nlocal function get(x, y)\13\n\9if x >= 1 and y >= 1 and x <= bufferWidth and y <= bufferHeight then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9else\13\n\9\9return 0x000000, 0x000000, \" \"\13\n\9end\13\nend\13\n\13\nlocal function set(x, y, background, foreground, symbol)\13\n\9if x >= drawLimitX1 and y >= drawLimitY1 and x <= drawLimitX2 and y <= drawLimitY2 and isDrawable(x, y) then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9if bufferOnly then\13\n\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawRectangle(x, y, width, height, background, foreground, symbol, transparency) \13\n\9local index, indexStepOnReachOfSquareWidth = bufferWidth * (y - 1) + x, bufferWidth - width\13\n\9for j = y, y + height - 1 do\13\n\9\9if j >= drawLimitY1 and j <= drawLimitY2 then\13\n\9\9\9for i = x, x + width - 1 do\13\n\9\9\9\9if i >= drawLimitX1 and i <= drawLimitX2 and isDrawable(i, j) then\13\n\9\9\9\9\9if transparency then\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9colorBlend(newFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9colorBlend(newFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9index = index + 1\13\n\9\9\9end\13\n\13\n\9\9\9index = index + indexStepOnReachOfSquareWidth\13\n\9\9else\13\n\9\9\9index = index + bufferWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clear(color, transparency)\13\n\9drawRectangle(1, 1, bufferWidth, bufferHeight, color or 0x0, 0x000000, \" \", transparency)\13\nend\13\n\13\nlocal function copy(x, y, width, height, current)\13\n\9local copyArray, index = { width, height }\13\n\9local rawCopyArray = { width, height }\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, newFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameSymbols[index])\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameForegrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameSymbols[index])\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, \" \")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return copyArray, rawCopyArray\13\nend\13\n\13\nlocal function paste(startX, startY, picture, currentPicture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\9\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9newFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9\9if currentPicture ~= nil then\13\n\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = currentPicture[pictureIndex]\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = currentPicture[pictureIndex + 1]\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = currentPicture[pictureIndex + 2]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function copyCurrent(x, y, width, height)\13\n\9local copyArray, index = { width, height }\13\n\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameSymbols[index])\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return copyArray\13\nend\13\n\13\nlocal function pasteCurrent(startX, startY, picture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9currentFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function directCopy(x, y, width, height, tx, ty, current, actualBuffer)\13\n\9local index\13\n\9local imageWidth = width\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (ty - 1) + tx, 3, bufferWidth - imageWidth\13\n\9\13\n\9local newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols\13\n\9\13\n\9if actualBuffer then\13\n\9\9newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9else\13\n\9\9newBackgrounds, newForegrounds, newSymbols = {table.unpack(newFrameBackgrounds)}, {table.unpack(newFrameForegrounds)}, {table.unpack(newFrameSymbols)}\13\n\9\13\n\9\13\n\9\9if current or bufferOnly then\13\n\9\9\9currentBackgrounds, currentForegrounds, currentSymbols = {table.unpack(currentFrameBackgrounds)}, {table.unpack(currentFrameForegrounds)}, {table.unpack(currentFrameSymbols)}\13\n\9\9end\13\n\9end\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9local newX, newY = getCoordinates(bufferIndex)\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(ewX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9newForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9newSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = currentFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = currentFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = currentFrameSymbols[index]\13\n\9\9\9\9\9\9--[[\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\9]]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(newX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9--[[\13\n\9\9\9\9\9newBackgrounds[newIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[newIndex] = 0x0\13\n\9\9\9\9\9newSymbols[newIndex] = \" \"\13\n\9\9\9\9\9]]\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9end\13\n\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9end\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = newBackgrounds, newForegrounds, newSymbols\13\n\9if current or bufferOnly then\13\n\9\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols = currentBackgrounds, currentForegrounds, currentSymbols\13\n\9end\13\nend\13\n\13\nlocal function rasterizeLine(x1, y1, x2, y2, method)\13\n\9local inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = x1, x2, y1, y2, false, mathAbs(x2 - x1), mathAbs(y2 - y1)\13\n\9if inLoopValueDelta < outLoopValueDelta then\13\n\9\9inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = y1, y2, x1, x2, true, outLoopValueDelta, inLoopValueDelta\13\n\9end\13\n\13\n\9if outLoopValueFrom > outLoopValueTo then\13\n\9\9outLoopValueFrom, outLoopValueTo = outLoopValueTo, outLoopValueFrom\13\n\9\9inLoopValueFrom, inLoopValueTo = inLoopValueTo, inLoopValueFrom\13\n\9end\13\n\13\n\9local outLoopValue, outLoopValueCounter, outLoopValueTriggerIncrement = outLoopValueFrom, 1, inLoopValueDelta / outLoopValueDelta\13\n\9local outLoopValueTrigger = outLoopValueTriggerIncrement\13\n\9for inLoopValue = inLoopValueFrom, inLoopValueTo, inLoopValueFrom < inLoopValueTo and 1 or -1 do\13\n\9\9if isReversed then\13\n\9\9\9method(outLoopValue, inLoopValue)\13\n\9\9else\13\n\9\9\9method(inLoopValue, outLoopValue)\13\n\9\9end\13\n\13\n\9\9outLoopValueCounter = outLoopValueCounter + 1\13\n\9\9if outLoopValueCounter > outLoopValueTrigger then\13\n\9\9\9outLoopValue, outLoopValueTrigger = outLoopValue + 1, outLoopValueTrigger + outLoopValueTriggerIncrement\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function rasterizeEllipse(centerX, centerY, radiusX, radiusY, method)\13\n\9local function rasterizeEllipsePoints(XP, YP)\13\n\9\9method(centerX + XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY - YP)\13\n\9\9method(centerX + XP, centerY - YP) \13\n\9end\13\n\13\n\9local x, y, changeX, changeY, ellipseError, twoASquare, twoBSquare = radiusX, 0, radiusY * radiusY * (1 - 2 * radiusX), radiusX * radiusX, 0, 2 * radiusX * radiusX, 2 * radiusY * radiusY\13\n\9local stoppingX, stoppingY = twoBSquare * radiusX, 0\13\n\13\n\9while stoppingX >= stoppingY do\13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9y, stoppingY, ellipseError = y + 1, stoppingY + twoASquare, ellipseError + changeY\13\n\9\9changeY = changeY + twoASquare\13\n\13\n\9\9if (2 * ellipseError + changeX) > 0 then\13\n\9\9\9x, stoppingX, ellipseError = x - 1, stoppingX - twoBSquare, ellipseError + changeX\13\n\9\9\9changeX = changeX + twoBSquare\13\n\9\9end\13\n\9end\13\n\13\n\9x, y, changeX, changeY, ellipseError, stoppingX, stoppingY = 0, radiusY, radiusY * radiusY, radiusX * radiusX * (1 - 2 * radiusY), 0, 0, twoASquare * radiusY\13\n\13\n\9while stoppingX <= stoppingY do \13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9x, stoppingX, ellipseError = x + 1, stoppingX + twoBSquare, ellipseError + changeX\13\n\9\9changeX = changeX + twoBSquare\13\n\9\9\13\n\9\9if (2 * ellipseError + changeY) > 0 then\13\n\9\9\9y, stoppingY, ellipseError = y - 1, stoppingY - twoASquare, ellipseError + changeY\13\n\9\9\9changeY = changeY + twoASquare\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawLine(x1, y1, x2, y2, background, foreground, symbol)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawEllipse(centerX, centerY, radiusX, radiusY, background, foreground, symbol)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawText(x, y, textColor, data, transparency)\13\n\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9local charIndex, bufferIndex = 1, bufferWidth * (y - 1) + x\13\n\9\9\13\n\9\9for charIndex = 1, unicodeLen(data) do\13\n\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9if transparency then\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9end\13\n\9\9\9\9else\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9newFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\13\n\9\9\9x, bufferIndex = x + 1, bufferIndex + 1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawImage(startX, startY, picture, blendForeground)\13\n\9local bufferIndex, pictureIndex, imageWidth, backgrounds, foregrounds, alphas, symbols = bufferWidth * (startY - 1) + startX, 1, picture[1], picture[3], picture[4], picture[5], picture[6]\13\n\9local bufferIndexStepOnReachOfImageWidth = bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9if alphas[pictureIndex] == 0 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex], newFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex], currentFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] > 0 and alphas[pictureIndex] < 1 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if blendForeground then\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] == 1 and symbols[pictureIndex] ~= \" \" then\13\n\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 1\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(x, y, width, height, color)\13\n\9local stringUp, stringDown, x2 = \"┌\" .. string.rep(\"─\", width - 2) .. \"┐\", \"└\" .. string.rep(\"─\", width - 2) .. \"┘\", x + width - 1\13\n\9\13\n\9drawText(x, y, color, stringUp); y = y + 1\13\n\9for i = 1, height - 2 do\13\n\9\9drawText(x, y, color, \"│\")\13\n\9\9drawText(x2, y, color, \"│\")\13\n\9\9y = y + 1\13\n\9end\13\n\9drawText(x, y, color, stringDown)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function semiPixelRawSet(index, color, yPercentTwoEqualsZero, internalRun) --ToDo\13\n\9local upperPixel, lowerPixel, bothPixel = \"▀\", \"▄\", \" \"\13\n\9local backgroundBuffer, foregroundBuffer, symbolBuffer = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\n\9\13\n\9if internalRun then\13\n\9\9backgroundBuffer, foregroundBuffer, symbolBuffer = currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9end\13\n\9\13\n\9local background, foreground, symbol = backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index]\13\n\13\n\9if yPercentTwoEqualsZero then\13\n\9\9if symbol == upperPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9end\13\n\9else\13\n\9\9if symbol == lowerPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9end\13\n\9end\13\n\9\13\n\9if bufferOnly and not internalRun then\13\n\9\9semiPixelRawSet(index, color, yPercentTwoEqualsZero, true)\13\n\9end\13\nend\13\n\13\nlocal function semiPixelSet(x, y, color)\13\n\9local yFixed = mathCeil(y / 2)\13\n\9if x >= drawLimitX1 and yFixed >= drawLimitY1 and x <= drawLimitX2 and yFixed <= drawLimitY2 and isDrawable(x, yFixed) then\13\n\9\9semiPixelRawSet(bufferWidth * (yFixed - 1) + x, color, y % 2 == 0)\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelRectangle(x, y, width, height, color)\13\n\9local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = bufferWidth * (mathCeil(y / 2) - 1) + x, (bufferWidth - width), width\13\n\9for j = y, y + height - 1 do\13\n\9\9jPercentTwoEqualsZero = j % 2 == 0\13\n\9\9\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9jFixed = mathCeil(j / 2)\13\n\9\9\9semiPixelRawSet(index, color, jPercentTwoEqualsZero)\13\n\9\9\9index = index + 1\13\n\9\9end\13\n\13\n\9\9if jPercentTwoEqualsZero then\13\n\9\9\9index = index + indexStepForward\13\n\9\9else\13\n\9\9\9index = index - indexStepBackward\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelLine(x1, y1, x2, y2, color)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\nlocal function drawSemiPixelEllipse(centerX, centerY, radiusX, radiusY, color)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getPointTimedPosition(firstPoint, secondPoint, time)\13\n\9return {\13\n\9\9x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,\13\n\9\9y = firstPoint.y + (secondPoint.y - firstPoint.y) * time\13\n\9}\13\nend\13\n\13\nlocal function getConnectionPoints(points, time)\13\n\9local connectionPoints = {}\13\n\9for point = 1, #points - 1 do\13\n\9\9tableInsert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))\13\n\9end\13\n\9return connectionPoints\13\nend\13\n\13\nlocal function getMainPointPosition(points, time)\13\n\9if #points > 1 then\13\n\9\9return getMainPointPosition(getConnectionPoints(points, time), time)\13\n\9else\13\n\9\9return points[1]\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelCurve(points, color, precision)\13\n\9local linePoints = {}\13\n\9for time = 0, 1, precision or 0.01 do\13\n\9\9tableInsert(linePoints, getMainPointPosition(points, time))\13\n\9end\13\n\9\13\n\9for point = 1, #linePoints - 1 do\13\n\9\9drawSemiPixelLine(mathFloor(linePoints[point].x), mathFloor(linePoints[point].y), mathFloor(linePoints[point + 1].x), mathFloor(linePoints[point + 1].y), color)\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function drawChanges(force)\13\n\9local index, indexStepOnEveryLine, changes = bufferWidth * (drawLimitY1 - 1) + drawLimitX1, (bufferWidth - drawLimitX2 + drawLimitX1 - 1), {}\13\n\9local x, equalChars, equalCharsIndex, charX, charIndex, currentForeground\13\n\9local currentFrameBackground, currentFrameForeground, currentFrameSymbol, changesCurrentFrameBackground, changesCurrentFrameBackgroundCurrentFrameForeground\13\n\13\n\9local changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\13\n\9for y = drawLimitY1, drawLimitY2 do\13\n\9\9x = drawLimitX1\13\n\9\9while x <= drawLimitX2 do\9\9\9\13\n\9\9\9-- Determine if some pixel data was changed (or if <force> argument was passed)\13\n\9\9\9if\13\n\9\9\9\9currentFrameBackgrounds[index] ~= newFrameBackgrounds[index] or\13\n\9\9\9\9currentFrameForegrounds[index] ~= newFrameForegrounds[index] or\13\n\9\9\9\9currentFrameSymbols[index] ~= newFrameSymbols[index] or\13\n\9\9\9\9force\13\n\9\9\9then\13\n\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9currentFrameBackground, currentFrameForeground, currentFrameSymbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9\9\9\9currentFrameBackgrounds[index] = currentFrameBackground\13\n\9\9\9\9currentFrameForegrounds[index] = currentFrameForeground\13\n\9\9\9\9currentFrameSymbols[index] = currentFrameSymbol\13\n\13\n\9\9\9\9-- Look for pixels with equal chars from right of current pixel\13\n\9\9\9\9equalChars, equalCharsIndex, charX, charIndex = {currentFrameSymbol}, 2, x + 1, index + 1\13\n\9\9\9\9while charX <= drawLimitX2 do\13\n\9\9\9\9\9-- Pixels becomes equal only if they have same background and (whitespace char or same foreground)\13\n\9\9\9\9\9if\9\13\n\9\9\9\9\9\9currentFrameBackground == newFrameBackgrounds[charIndex] and\13\n\9\9\9\9\9\9(\13\n\9\9\9\9\9\9\9newFrameSymbols[charIndex] == \" \" or\13\n\9\9\9\9\9\9\9currentFrameForeground == newFrameForegrounds[charIndex]\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9\9 \9currentFrameBackgrounds[charIndex] = newFrameBackgrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameForegrounds[charIndex] = newFrameForegrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameSymbols[charIndex] = newFrameSymbols[charIndex]\13\n\13\n\9\9\9\9\9 \9equalChars[equalCharsIndex], equalCharsIndex = currentFrameSymbols[charIndex], equalCharsIndex + 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9charX, charIndex = charX + 1, charIndex + 1\13\n\9\9\9\9end\13\n\13\n\9\9\9\9-- Group pixels that need to be drawn by background and foreground\13\n\9\9\9\9changes[currentFrameBackground] = changes[currentFrameBackground] or {}\13\n\9\9\9\9changesCurrentFrameBackground = changes[currentFrameBackground]\13\n\9\9\9\9changesCurrentFrameBackground[currentFrameForeground] = changesCurrentFrameBackground[currentFrameForeground] or {index = 1}\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground = changesCurrentFrameBackground[currentFrameForeground]\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForegroundIndex = changesCurrentFrameBackgroundCurrentFrameForeground.index\13\n\9\9\9\9\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = x, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = y, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = tableConcat(equalChars), changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9\13\n\9\9\9\9x, index, changesCurrentFrameBackgroundCurrentFrameForeground.index = x + equalCharsIndex - 2, index + equalCharsIndex - 2, changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\9\9\9end\13\n\13\n\9\9\9x, index = x + 1, index + 1\13\n\9\9end\13\n\13\n\9\9index = index + indexStepOnEveryLine\13\n\9end\13\n\9\13\n\9-- Draw grouped pixels on screen\13\n\9for background, foregrounds in pairs(changes) do\13\n\9\9GPUProxySetBackground(background)\13\n\13\n\9\9for foreground, pixels in pairs(foregrounds) do\13\n\9\9\9if currentForeground ~= foreground then\13\n\9\9\9\9GPUProxySetForeground(foreground)\13\n\9\9\9\9currentForeground = foreground\13\n\9\9\9end\13\n\13\n\9\9\9for i = 1, #pixels, 3 do\13\n\9\9\9\9GPUProxySet(pixels[i], pixels[i + 1], pixels[i + 2])\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9changes = nil\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nbindGPU(component.getPrimary(\"gpu\").address)\13\n\13\nreturn {\13\n\9getCoordinates = getCoordinates,\13\n\9getIndex = getIndex,\13\n\9setDrawLimit = setDrawLimit,\13\n\9resetDrawLimit = resetDrawLimit,\13\n\9getDrawLimit = getDrawLimit,\13\n\9flush = flush,\13\n\9setResolution = setResolution,\13\n\9bindScreen = bindScreen,\13\n\9bindGPU = bindGPU,\13\n\9getGPUProxy = getGPUProxy,\13\n\9getResolution = getResolution,\13\n\9getWidth = getWidth,\13\n\9getHeight = getHeight,\13\n\9getCurrentFrameTables = getCurrentFrameTables,\13\n\9getNewFrameTables = getNewFrameTables,\13\n\9setCurrentFrameTables = setCurrentFrameTables,\13\n\9setNewFrameTables = setNewFrameTables,\13\n\9setBufferOnly = setBufferOnly,\13\n\9getBufferOnly = getBufferOnly,\13\n\13\n\9rawSet = rawSet,\13\n\9rawGet = rawGet,\13\n\9get = get,\13\n\9set = set,\13\n\9clear = clear,\13\n\9copy = copy,\13\n\9paste = paste,\13\n\9directCopy = directCopy,\13\n\9copyCurrent = copyCurrent,\13\n\9pasteCurrent = pasteCurrent,\13\n\9rasterizeLine = rasterizeLine,\13\n\9rasterizeEllipse = rasterizeEllipse,\13\n\9semiPixelRawSet = semiPixelRawSet,\13\n\9semiPixelSet = semiPixelSet,\13\n\9drawChanges = drawChanges,\13\n\13\n\9drawRectangle = drawRectangle,\13\n\9drawLine = drawLine,\13\n\9drawEllipse = drawEllipse,\13\n\9drawText = drawText,\13\n\9drawImage = drawImage,\13\n\9drawFrame = drawFrame,\13\n\13\n\9drawSemiPixelRectangle = drawSemiPixelRectangle,\13\n\9drawSemiPixelLine = drawSemiPixelLine,\13\n\9drawSemiPixelEllipse = drawSemiPixelEllipse,\13\n\9drawSemiPixelCurve = drawSemiPixelCurve,\13\n\9\13\n\9setDrawAreas = setDrawAreas,\13\n\9resetDrawAreas = resetDrawAreas,\13\n\9getDrawAreas = getDrawAreas,\13\n\9setNonDrawAreas = setNonDrawAreas,\13\n\9resetNonDrawAreas = resetNonDrawAreas,\13\n\9getNonDrawAreas = getNonDrawAreas,\13\n\9\13\n\9setDrawAreaOffset = setDrawAreaOffset,\13\n\9getDrawAreaOffset = getDrawAreaOffset,\13\n\9resetDrawAreaOffset = resetDrawAreaOffset,\13\n}",["//data/libs/UT.lua"] = "--[[\13\n    UT Copyright (C) 2019-2020 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[UsefullThings libary\13\n\9\13\n]]\13\nlocal UT = {version = \"v0.7.2\"}\13\n\13\nfunction UT.parseArgs(...) --returns the first non nil parameter.\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction UT.seperatePath(path) --seperates a data path [\"./DIR/FILE.ENDING\"] into the dir path [\"./DIR/\"], the file name [\"FILE\"], and the file ending [\".ENDING\" or nil]\13\n\9if string.sub(path, #path) == \"/\" then\13\n\9\9return path\13\n\9end\13\n\9\13\n\9local dir, fileName, fileEnd = \"\", \"\", nil\13\n\9local tmpLatest = \"\"\13\n\9for s in string.gmatch(tostring(path), \"[^/]+\") do\13\n\9\9tmpLatest = s\13\n\9end\13\n\9dir = string.sub(path, 0, #path -#tmpLatest)\13\n\9for s in string.gmatch(tostring(tmpLatest), \"[^.]+\") do\13\n\9\9fileName = fileName .. s\13\n\9\9tmpLatest = s\13\n\9end\13\n\9if fileName == tmpLatest then\13\n\9\9fileName = tmpLatest\13\n\9else\13\n\9\9fileEnd = \".\" .. tmpLatest\13\n\9\9fileName = string.sub(fileName, 0, #fileName - #fileEnd +1)\13\n\9end\13\n\9\13\n\9return dir, fileName, fileEnd\13\nend\13\n\13\nfunction UT.getChars(s) --returns a array with the chars of the string.\13\n\9local chars = {}\13\n\9for c = 1, #s do\13\n\9\9chars[c] = string.sub(s, c, c)\13\n\9end\13\n\9return chars\13\nend\13\n\13\nfunction UT.makeString(c) --genetares a string from and array of chars/strings.\13\n\9local s = \"\"\13\n\9for c, v in ipairs(c) do\13\n\9\9s = s ..v\13\n\9end\13\n\9return s\13\nend\13\n\13\nfunction UT.inputCheck(m, c) --checks if a array (m) contains a value (c).\13\n\9for _, v in pairs(m) do\13\n\9\9if v == c then\13\n\9\9\9return true\13\n\9\9end\13\n\9end\13\n\9return false\13\nend\13\n\13\nfunction UT.fillString(s, amout, c) --fills a string (s) up with a (amout) of chars/strings (c).\13\n\9local s2 = s\13\n\9for c2 = 1, amout, 1 do\13\n\9\9s2 = s2 .. c\13\n\9end\13\n\9return s2\13\nend\13\n\13\n--[[Converts a table or an other variable type to a readable stirng.\13\n\9This is a modified \"Universal tostring\" routine from \"lua-users.org\".\13\n\9Original source code: <http://lua-users.org/wiki/TableSerialization>\13\n]]\13\nfunction UT.tostring(var, lineBreak, indent, done, internalRun) \13\n\9if internalRun == false or internalRun == nil then\13\n\9\9if type(var) == \"table\" then\13\n\9\9\9UT.tostring(var, lineBreak, indent, done, true)\13\n\9\9else\13\n\9\9\9return tostring(var)\13\n\9\9end\13\n\9end\13\n\9\13\n\9done = done or {}\13\n\9indent = indent or 2\13\n\9local lbString\13\n\9if lineBreak or lineBreak == nil then\13\n\9\9lbString = \"\\n\"\13\n\9\9lineBreak = true\13\n\9else\13\n\9\9lbString = \" \"\13\n\9end\13\n\9if type(var) == \"table\" then\13\n\9\9local sb = {}\13\n\9\9if not internalRun then\13\n\9\9\9table.insert(sb, \"{\" .. lbString)\13\n\9\9end\13\n\9\9for key, value in pairs (var) do\13\n\9\9\9if lineBreak then\13\n\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9end\13\n\9\9\9if type (value) == \"table\" and not done [value] then\13\n\9\9\9\9done [value] = true\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, \"[\" .. key .. \"] = {\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"[\" .. key .. \"] = {\");\13\n\9\9\9\9end\13\n\9\9\9\9table.insert(sb, UT.tostring(value, lineBreak, indent + 2, done, true))\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9\9\9table.insert(sb, \"},\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"},\");\13\n\9\9\9\9end\13\n\9\9\9elseif \"number\" == type(key) then\13\n\9\9\9\9table.insert(sb, string.format(\"[%s] = \", tostring(key)))\13\n\9\9\9\9table.insert(sb, string.format(\"\\\"%s\\\",\" .. lbString, tostring(value)))\13\n\9\9\9else\13\n\9\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9\9table.insert(sb, \" \")\13\n\9\9\9\9end\13\n\9\9\9\9table.insert(sb, string.format(\"%s = \\\"%s\\\",\" .. lbString, \"[\" .. tostring (key) .. \"]\", tostring(value)))\13\n\9\9\9end\13\n\9\9end\13\n\9\9if not internalRun then\13\n\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9table.insert(sb, \" }\")\13\n\9\9\9else\13\n\9\9\9\9table.insert(sb, \"}\")\13\n\9\9\9end\13\n\9\9end\13\n\9\9return table.concat(sb)\13\n\9else\13\n\9\9return var .. lbString\13\n\9end\13\nend\13\n\13\nreturn UT",["//data/libs/"] = 0,["//data/game.lua"] = "local usesDoubleBuffer = ...\13\n\13\nlocal version = \"v1.1.1\"\13\nlocal isDevVersion = false\13\n\13\nlocal component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal system = require(\"os\")\13\nlocal term = require(\"term\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\npackage.loaded.player = nil\13\nlocal player = require(\"player\")\13\npackage.loaded.player = nil\13\nlocal player2 = require(\"player\")\13\n\13\npackage.loaded.graphic = nil\13\nrequire(\"graphic\")\13\n\13\npackage.loaded.deltaTime = nil\13\nlocal delta = require(\"deltaTime\")\13\n\13\npackage.loaded.background = nil\13\nlocal background = require(\"background\")\13\n\13\nlocal deltaTime = 0\13\nlocal previousDeltaTime = 0\13\n\13\nlocal fpsCheckInterval = 20\13\nlocal deltaTimeTable = {}\13\nlocal fps = 0\13\nlocal frameCounter = 0\13\nlocal realDeltaTime = 0\13\n\13\nlocal lastBlinkTime = computer.uptime()\13\nlocal blinkState = true\13\nlocal lastLooser\13\n\13\nlocal gameIsRunning = true\13\n\13\n--==========--\13\nlocal blinkDelay = 1\13\n\13\nlocal resX = 80\13\nlocal resY = 25\13\n\13\nlocal sleepTime = 1 --caps it to about 20 fps\13\n\13\nlocal controls = require(\"libs/LIP\").load(\"../controls.ini\")\13\n\13\n--===== init =====--\13\nif usesDoubleBuffer then\13\n\9gpu = gpuProxy\13\nelse\13\n\9gpu = component.gpu\13\nend\13\n\13\n--=============== Functions ===============--\13\n\13\nfunction Start()\13\n\9player.Start()\13\n\9player2.Start()\13\n\13\n\9player.right = tostring(controls.player1.right)\13\n\9player.left = tostring(controls.player1.left)\13\n\9player.punch = tostring(controls.player1.punch)\13\n\9\13\n\9player2.right = tostring(controls.player2.right)\13\n\9player2.left = tostring(controls.player2.left)\13\n\9player2.punch = tostring(controls.player2.punch)\13\n\9\13\n\9player2.body.aSet[1] = {2, 1, \"   \", 0x000000, 0xbf2f11}\13\n\9player2.body.aSet[2] = {3, 0, \" \"}\13\n\9\13\n\9Reset()\13\nend\13\n\13\nfunction Update()\13\n\9if gameIsRunning then\13\n\9\9player.Update()\13\n\9\9player2.Update()\13\n\9\9\13\n\9\9Draw()\13\n\9\9\13\n\9\9if HitCheck(player, player2) then\13\n\9\9\9player2.life = player2.life - (player.charge /2)\13\n\9\9\9player.charge = 0\13\n\9\9end\13\n\9\9if HitCheck(player2, player) then\13\n\9\9\9player.life = player.life - (player2.charge /2)\13\n\9\9\9player2.charge = 0\13\n\9\9end\13\n\9\9\13\n\9\9if player2.life <= 0 and player.life <= 0 then\13\n\9\9\9GameOver(0)\13\n\9\9else\13\n\9\9\9if player.life <= 0 then\13\n\9\9\9\9GameOver(\"Player2\")\13\n\9\9\9elseif player2.life <= 0 then\13\n\9\9\9\9GameOver(\"Player1\")\13\n\9\9\9end\13\n\9\9end\13\n\9else\13\n\9\9if computer.uptime() - lastBlinkTime > blinkDelay then\13\n\9\9\9if blinkState then\13\n\9\9\9\9DrawResetText()\13\n\9\9\9\9blinkState = false\13\n\9\9\9else\13\n\9\9\9\9Draw()\13\n\9\9\9\9GameOver(lastLooser)\13\n\9\9\9\9blinkState = true\13\n\9\9\9end\13\n\9\9\9lastBlinkTime = computer.uptime()\13\n\9\9end\13\n\9end\13\nend\13\n\13\n\13\nfunction Draw()\13\n\9--gpu.fill(1, 1, resX, resY, \" \")\13\n\9--DrawAt(testTexture, 0, 0, gpu)\13\n\9\13\n\9ClearAt(player2.body, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player.body, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player.arm2, player.oldPosX, player.oldPosY, gpu)\13\n\9ClearAt(player.arm3, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player2.arm2, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player2.arm3, player2.oldPosX, player2.oldPosY, gpu)\13\n\9\13\n\9--Background\13\n\9DrawAt(background.street, 1, 17, gpu)\13\n\9\13\n\9--Player\13\n\9\13\n\9DrawAt(player.body, player.posX, player.posY, gpu)\13\n\9DrawAt(player2.body, player2.posX, player2.posY, gpu)\13\n\9\13\n\9DrawArms(player)\13\n\9DrawArms(player2)\13\n\9\13\n\9LifeGui()\13\nend\13\n\13\nfunction LifeGui() \13\n\9DrawAt({\13\n\9\9fillSize = 4,\13\n\9\9aFill = {\13\n\9\9\9[1] = {2, 1, 36, 5, \" \", 0x000000, 0xaaaaaa},\13\n\9\9\9[2] = {42, 1, 36, 5, \" \", 0x000000, 0xaaaaaa},\13\n\9\9\9\13\n\9\9},\13\n\9\9\13\n\9\9setSize = 2,\13\n\9\9aSet = {\13\n\9\9\9\13\n\9\9},\13\n\9}, 1, 1, gpu)\13\n\9gpu.setBackground(0x000000)\13\n\9gpu.set(5, 3, \"                                \")\13\n\9gpu.set(45, 3, \"                                \")\13\n\9gpu.set(5, 5, \"                                \")\13\n\9gpu.set(45, 5, \"                                \")\13\n\9gpu.setBackground(0x00aa00)\13\n\9gpu.fill(5, 3, player.life, 1, \" \")\13\n\9gpu.fill(45, 3, player2.life, 1, \" \")\13\n\9gpu.setBackground(0x000000ff)\13\n\9gpu.fill(5, 5, player.charge, 1, \" \")\13\n\9gpu.fill(45, 5, player2.charge, 1, \" \")\13\n\9\13\n\9gpu.setForeground(0xaaaaaa)\13\n\9gpu.setBackground(0x00509f)\13\n\9gpu.set(resX / 2 - unicode.len(version) / 2 + 1, 1, version)\13\nend\13\n\13\nfunction HitCheck(p1, p2)\13\n\9if p1.looksLeft then\13\n\9\9if p1.isPunching then\13\n\9\9\9if p1.posX <= p2.posX + 10 and p1.posX > p2.posX + 5 then\13\n\9\9\9\9return true\13\n\9\9\9end\13\n\9\9end\13\n\9elseif p1.looksLeft == false then\13\n\9\9if p1.isPunching then\13\n\9\9\9if p1.posX + 10 >= p2.posX and p1.posX + 5 < p2.posX then\13\n\9\9\9\9return true\13\n\9\9\9end\13\n\9\9end\13\n\9else\13\n\9\9return false\13\n\9end\13\nend\13\n\13\nfunction DrawArms(player)\9\13\n\9if player.isCharging then\13\n\9\9DrawAt(player.arm2, player.posX, player.posY, gpu)\13\n\9elseif player.isPunching then\13\n\9\9DrawAt(player.arm3, player.posX, player.posY, gpu)\13\n\9else\13\n\9\9DrawAt(player.arm1, player.posX, player.posY, gpu)\13\n\9end\13\nend\13\n\13\nfunction GameOver(name)\13\n\9LifeGui()\13\n\9\13\n\9if name ~= 0 then\13\n\9\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 4,\13\n\9\9aSet = {\13\n\9\9\9[1] = {28, 6, \"########################\", 0x500000, 0xba0000},\13\n\9\9\9[2] = {28, 7, \"##     GameOver!      ##\", 0x500000, 0xba0000},\13\n\9\9\9[3] = {28, 8, \"##  \" .. name .. \" has won!  ##\"},\13\n\9\9\9[4] = {28, 9, \"########################\", 0x500000, 0xba0000},\13\n\9\9}}, 1, 1, gpu)\13\n\9else\13\n\9\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 4,\13\n\9\9aSet = {\13\n\9\9\9[1] = {28, 6, \"########################\", 0x500000, 0xba0000},\13\n\9\9\9[2] = {28, 7, \"##     GameOver!      ##\", 0x500000, 0xba0000},\13\n\9\9\9[3] = {28, 8, \"##       Tie!         ##\"},\13\n\9\9\9[4] = {28, 9, \"########################\", 0x500000, 0xba0000},\13\n\9\9}}, 1, 1, gpu)\13\n\9end\13\n\13\n\9if blinkState then\13\n\9\9DrawResetText()\13\n\9end\13\n\9\13\n\9gameIsRunning = false\13\n\9lastLooser = name\13\nend\13\n\13\nfunction DrawResetText()\13\n\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 1,\13\n\9\9aSet = {\13\n\9\9\9[1] = {30, 12, \" Press R to restart \", 0x705000, 0xee6000},\13\n\9}}, 1, 9, gpu)\13\nend\13\n\13\nfunction Reset() \13\n\9player.posX = 5\13\n\9player.life = player.maxLife\13\n\9player.charge = 0\13\n\9player.TurnAround(false)\13\n\9\13\n\9player2.posX = 70\13\n\9player2.life = player2.maxLife\13\n\9player2.charge = 0\13\n\9player2.TurnAround(true)\13\n\9\13\n\9gameIsRunning = true\13\n\9\13\n\9blinkState = true\13\n\9\13\n\9ClearAt(player2.body, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player.body, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player.arm2, player.oldPosX, player.oldPosY, gpu)\13\n\9ClearAt(player.arm3, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player2.arm2, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player2.arm3, player2.oldPosX, player2.oldPosY, gpu)\13\n\9\13\nend\13\n\13\nfunction Reload() --For DEV\13\n\9ClearAt(background.street, 1, 17, gpu)\13\n\9package.loaded.background = nil\13\n\9background = require(\"background\")\13\nend\13\nlocal devCount = 0\13\n\13\n--=============== Main while ===============--\13\nterm.clear()\13\ngpu.setResolution(resX, resY)\13\n\13\n\13\nStart()\13\nwhile true do\13\n\9Update()\13\n\9--system.sleep(0.001)\13\n\9deltaTime = (computer.uptime() - previousDeltaTime) * 100 / 7\13\n\9realDeltaTime = computer.uptime() - previousDeltaTime\13\n\9previousDeltaTime = computer.uptime()\13\n\9\13\n\9if isDevVersion then\13\n\9\9if frameCounter >= fpsCheckInterval then\13\n\9\9\9frameCounter = 0\13\n\9\9end\13\n\9\9deltaTimeTable[frameCounter] = realDeltaTime\13\n\9\9local frameTimes = 0\13\n\9\9for i, c in pairs(deltaTimeTable) do\13\n\9\9\9frameTimes = frameTimes + c\13\n\9\9end\13\n\9\9frameCounter = frameCounter +1\13\n\9\9fps = 1 / (frameTimes / #deltaTimeTable)\13\n\13\n\9\9gpu.setForeground(0xaaaaaa)\13\n\9\9gpu.setBackground(0x000000)\13\n\9\9gpu.set(1, 1, \"                              \")\13\n\9\9delta.Set()\13\n\9\9--gpu.set(1, 1, \"Delta time: \" .. deltaTime .. \" | \" .. (sleepTime - deltaTime) / 1000 .. \" | \" )\13\n\9\9gpu.set(1, 1, \"FPS: \" .. fps)\13\n\9end\13\n\13\n\9if usesDoubleBuffer then\13\n\9\9gpu.drawChanges()\13\n\9end\13\n\9\13\n\9if keyboard.isKeyDown(controls.game.quit) then\13\n\9\9gpu.setForeground(0xaaaaaa)\13\n\9\9gpu.setBackground(0x000000)\13\n\9\9--print(\"BREAK                       \")\13\n\9\9break\13\n\9elseif keyboard.isKeyDown(controls.game.reset) then\13\n\9\9Reset()\13\n\9end\13\n\9if keyboard.isKeyDown('t') then\13\n\9\9Reload()\13\n\9\9devCount = 0\13\n\9end\13\n\13\n\9os.sleep((sleepTime - deltaTime) / 1000)\13\nend\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n",["//data/player.lua"] = "local Player = {}\13\n\13\nPlayer.left = nil\13\nPlayer.right = nil\13\nPlayer.punch = nil\13\n\13\nPlayer.posX = 0\13\nPlayer.posY = 13\13\n\13\nPlayer.life = 32\13\nPlayer.maxLife = 32\13\nPlayer.charge = 0\13\nPlayer.maxCharge = 32\13\n\13\nPlayer.oldPosX = Player.posX\13\nPlayer.oldPosY = Player.posY\13\n\13\nPlayer.keyboard = require(\"keyboard\")\13\n\13\nPlayer.looksLeft = false\13\nPlayer.isPunching = false\13\nPlayer.isCharging = false\13\n\13\nPlayer.face = 10\13\nPlayer.punchTime = 2\13\nPlayer.punchCount = 0\13\n\13\nPlayer.clearArm2 = false\13\nPlayer.clearArm3 = false\13\n\13\nfunction Player:Start()\13\n\13\nend\13\n\13\nfunction Player:Update()\13\n\9Player.oldPosX = Player.posX\13\n\9Player.oldPosX = Player.posX\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.right) and Player.isPunching == false then\13\n\9\9Player.posX = Player.posX +1\13\n\9\9Player.TurnAround(false)\13\n\9end\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.left) and Player.isPunching == false then\13\n\9\9Player.posX = Player.posX -1\13\n\9\9Player.TurnAround(true)\13\n\9end\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.punch) and Player.isPunching == false and Player.charge < Player.maxCharge then --Charge\13\n\9\9Player.isCharging = true\13\n\9\9if Player.charge < Player.maxCharge then\13\n\9\9\9Player.charge = Player.charge +2\13\n\9\9end\13\n\9elseif Player.isCharging then --Activate punch\13\n\9\9Player.isCharging = false\13\n\9\9Player.clearArm2 = true\13\n\9\9Player.isPunching = true\13\n\9end\13\n\9\13\n\9if Player.isPunching and Player.punchCount == Player.punchTime then --Reset punch\13\n\9\9Player.isPunching = false\13\n\9\9Player.clearArm3 = true\13\n\9\9Player.punchCount = 0\13\n\9\9Player.charge = 0\13\n\9elseif Player.isPunching then\13\n\9\9Player.punchCount = Player.punchCount +1\13\n\9end\13\nend\13\n\13\nfunction Player.TurnAround(lookLeft) \13\n\9if lookLeft then\13\n\9\9Player.looksLeft = true\13\n\9\9\13\n\9\9Player.body.aSet[Player.face][3] = \"o  \"\13\n\9\9Player.arm1.aSet = {\13\n\9\9\9[1] = {2, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9\9Player.arm2.aSet = {\13\n\9\9\9[1] = {4, 4, \"B\", 0x000000, 0xbbbb00},\13\n\9\9\9[2] = {6, 4, \"  \", 0x000000, 0x0000ff},\13\n\9\9}\13\n\9\9Player.arm3.aSet = {\13\n\9\9\9[2] = {-4, 3, \"     \", 0x000000, 0x0000ff},\13\n\9\9\9[3] = {-5, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9else\13\n\9\9Player.looksLeft = false\13\n\9\9\13\n\9\9Player.body.aSet[Player.face][3] = \"  o\"\13\n\9\9Player.arm1.aSet = {\13\n\9\9\9[1] = {4, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9\9Player.arm2.aSet = {\13\n\9\9\9[1] = {2, 4, \"B\", 0x000000, 0xbbbb00},\13\n\9\9\9[2] = {-1, 4, \"  \", 0x000000, 0x0000ff},\13\n\9\9}\13\n\9\9Player.arm3.aSet = {\13\n\9\9\9[2] = {6, 3, \"     \", 0x000000, 0x0000ff},\13\n\9\9\9[3] = {11, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9end\13\nend\13\n\13\nPlayer.body = {\13\n\9fillSize = 100,\13\n\9aFill = {\13\n\9\9[1] = {1, 3, 5, 3, \" \", 0x000000, 0x0000ff}, --Body\13\n\9\9\13\n\9\9[2] = {2, 7, 1, 3, \" \", 0x000000, 0x00aa00}, --Legs\13\n\9\9[3] = {4, 7, 1, 3, \" \"},\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 100,\13\n\9aSet = {\13\n\9\9[1] = {2, 1, \"   \", 0x000000, 0x7f2f11}, --Head\13\n\9\9--[2] = {} Payer2\13\n\9\9\13\n\9\9[10] = {2, 2, \"  o\", 0x000000, 0xbbbb00}, --Face\13\n\9\9\13\n\9\9[3] = {1, 6, \"     \", 0x000000, 0x00aa00}, --Leg\13\n\9\9\13\n\9\9[11] = {2, 9, \" \", 0x000000, 0x4f1f01}, --Shoe\13\n\9\9[12] = {4, 9, \" \"}, --Shoe\13\n\9\9\13\n\9},\13\n}\13\n\13\nPlayer.arm1 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 1,\13\n\9aSet = {\13\n\9\9[1] = {4, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9},\13\n}\13\n\13\nPlayer.arm2 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 2,\13\n\9aSet = {\13\n\9\9\13\n\9},\13\n}\13\n\13\nPlayer.arm3 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 3,\13\n\9aSet = {\13\n\9\9[2] = {6, 3, \"    \", 0x000000, 0x0000ff},\13\n\9\9[3] = {10, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9},\13\n}\13\n\13\n\13\nreturn Player\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n",["//data/graphic.lua"] = "--GraphicLib v0.1\13\n\13\nfunction ClearAt(t, posX, posY, gpu)\13\n\9AddToTexture(t, posX, posY)\13\n\9ClearTexture(t, gpu)\13\n\9AddToTexture(t, -posX, -posY)\13\nend\13\n\13\nfunction ClearTexture(t, gpu) \13\n\9gpu.setBackground(0x000000)\13\n\9for c = 1, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9if t.aFill[c][5] ~= nil then\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], \" \")\13\n\9\9\9end\9\9\13\n\9\9end\13\n\9end\13\n\13\n\9for c = 1, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9if t.aSet[c][3] ~= nil then\13\n\9\9\9\9gpu.fill(t.aSet[c][1], t.aSet[c][2], string.len(t.aSet[c][3]), 1, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction DrawAt(t, posX, posY, gpu)\13\n\9AddToTexture(t, posX, posY)\13\n\9DrawTexture(t, gpu)\13\n\9AddToTexture(t, -posX, -posY)\13\nend\13\n\13\nfunction DrawTexture(t, gpu) \13\n\9local previousForeground = gpu.getForeground()\13\n\9local previousBackground = gpu.getBackground()\13\n\9for c = 1, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9if t.aFill[c][6] ~= nil then\13\n\9\9\9\9if previousForeground ~= t.aFill[c][6] then\13\n\9\9\9\9\9gpu.setForeground(t.aFill[c][6])\13\n\9\9\9\9\9previousForeground = t.aFill[c][6]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aFill[c][7] then\13\n\9\9\9\9\9gpu.setBackground(t.aFill[c][7])\13\n\9\9\9\9\9previousBackground = t.aFill[c][7]\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], t.aFill[c][5])\13\n\9\9\9elseif #t.aFill[c] == 2 then\13\n\9\9\9\9if previousForeground ~= t.aFill[c][1] then\13\n\9\9\9\9\9gpu.setForeground(t.aFill[c][1])\13\n\9\9\9\9\9previousForeground = t.aFill[c][1]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aFill[c][2] then\13\n\9\9\9\9\9gpu.setBackground(t.aFill[c][2])\13\n\9\9\9\9\9previousBackground = t.aFill[c][2]\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], t.aFill[c][5])\13\n\9\9\9end\13\n\9\9\9\13\n\9\9end\13\n\9end\13\n\13\n\9for c = 1, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9if t.aSet[c][4] ~= nil then\13\n\9\9\9\9if previousForeground ~= t.aSet[c][4] then\13\n\9\9\9\9\9gpu.setForeground(t.aSet[c][4])\13\n\9\9\9\9\9previousForeground = t.aSet[c][4]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aSet[c][5] then\13\n\9\9\9\9\9gpu.setBackground(t.aSet[c][5])\13\n\9\9\9\9\9previousBackground = t.aSet[c][5]\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9gpu.set(t.aSet[c][1], t.aSet[c][2], t.aSet[c][3])\13\n\9\9\9elseif #t.aSet[c] == 2 then\13\n\9\9\9\9if previousForeground ~= t.aSet[c][1] then\13\n\9\9\9\9\9gpu.setForeground(t.aSet[c][1])\13\n\9\9\9\9\9previousForeground = t.aSet[c][1]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aSet[c][2] then\13\n\9\9\9\9\9gpu.setBackground(t.aSet[c][2])\13\n\9\9\9\9\9previousBackground = t.aSet[c][2]\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9gpu.set(t.aSet[c][1], t.aSet[c][2], t.aSet[c][3])\13\n\9\9\9end\13\n\9\9\9\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction AddToTexture(t, x, y)\13\n\9for c = 0, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9t.aFill[c][1] = t.aFill[c][1] + x\13\n\9\9\9t.aFill[c][2] = t.aFill[c][2] + y\13\n\9\9end\13\n\9end\13\n\9for c = 0, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9t.aSet[c][1] = t.aSet[c][1] + x\13\n\9\9\9t.aSet[c][2] = t.aSet[c][2] + y\13\n\9\9end\13\n\9end\13\nend",["//data/deltaTime.lua"] = "local Delta = {}\13\nlocal computer = require(\"computer\")\13\n\13\nDelta.time = 0\13\nDelta.previousDeltaTime = 0\13\n\13\nfunction Delta:Set() \13\n\9Delta.time = os.difftime(computer.uptime(), Delta.previousDeltaTime)\13\n\9Delta.time = Delta.time / 70 * 1000\13\n\9Delta.previousDeltaTime = computer.uptime()\13\nend\13\n\13\n\13\nreturn Delta",["//data/background.lua"] = "local b = {}--Backgound\13\n\13\nb.street = {\13\n\9fillSize = 100,\13\n\9aFill = {\13\n\9\9[1] = {0, -17, 80, 25, \" \", 0x000000, 0x00509f},\13\n\9\9[2] = {0, 1, 80, 7, \" \", 0x000000, 0x666666},\13\n\9\9\13\n\9\9\13\n\9\9[9] = {5, -7, 7, 8, \" \", 0x00ff00, 0x777788},\13\n\9\9\13\n\9\9[11] = {22, -8, 2, 8, \" \", 0x00ff00, 0x878798},\13\n\9\9[12] = {39, -8, 2, 8, \" \"},\13\n\9\9[13] = {22, -9, 19, 7, \" \"},\13\n\9\9\13\n\9\9[14] = {24, -8, 15, 5, \"#\", 0xffe900, 0xdf00af},\13\n\9\9[15] = {6, -6, 5, 4, \"#\", 0x00dd00, 0xee0000},\13\n\9\9\13\n\9\9[16] = {46, -8, 1, 8, \" \", 0x00ff00, 0xb1bcdb},\13\n\9\9\13\n\9\9[17] = {53, -8, 2, 8, \"|\", 0x989bae, 0x9daac1},\13\n\9\9[18] = {55, -8, 27, 8, \" \", 0x989bae, 0x3581aa},\13\n\9\9[19] = {70, -8, 1, 8, \"|\", 0x989bae, 0x9daac1},\13\n\9\9\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 40,\13\n\9aSet = {\13\n\9\9--[10] = {0, -1, \"    |         |         |         |         |         |         |         |     \", 0x434343, 0x444444},\13\n\9\9[11] = {0, 8, \"       |         |         |         |         |         |         |         |  \", 0x434343, 0x444444},\13\n\9\9[12] = {0, 0, \"    |         |         |         |         |         |         |         |     \", 0x333333, 0x404040},\13\n\9\9[2] = {3, 4, \"        \", 0x000000, 0xbbbbbb},\13\n\9\9[3] = {22, 4, \"        \"},\13\n\9\9[4] = {41, 4, \"        \"},\13\n\9\9[5] = {60, 4, \"        \"},\13\n\9\9[6] = {79, 4, \" \"},\13\n\9\9\13\n\9\9[20] = {14, -3, \"\\\\    /\", 0x3f3f3f, 0x555555},\13\n\9\9[21] = {15, -2, \"IHHI\"},\13\n\9\9[22] = {15, -1, \"IHHI\"},\13\n\9\9\13\n\9\9[23] = {45, -9, \" # \", 0xaaaaaa, 0xcc2222},\13\n\9\9[24] = {44, -8, \" ### \", 0x555555, 0xdddddd},\13\n\9\9[25] = {45, -7, \" # \", 0xaaaaaa, 0x4455dd},\13\n\9\9\13\n\9\9[26] = {51, -9, \"/=vv===============v==========\", 0x989bae, 0x9daac1},\13\n\9\9\13\n\9\9[27] = {59, -2, \"                  \", 0x989bae, 0x4d310c},\13\n\9\9\13\n\9\9[28] = {61, -1, \" \", 0x989bae, 0x4c1501},\13\n\9\9[29] = {74, -1, \" \"},\13\n\9\9\13\n\9},\13\n}\13\n\13\nreturn b",["//data/"] = 0,["//controls.ini"] = "# StreetFucker controls.\n# Only one key per action supported.\n\n[game]\nreset=r\nquit=q\n\n[player1]\nleft=a\nright=d\npunch= \n\n[player2]\nleft=j\nright=l\npunch=0",["//startGame.lua"] = "local shell = require(\"shell\")\nlocal currentWorkingDir = shell.getWorkingDirectory()\nshell.setWorkingDirectory(currentWorkingDir .. \"/data\")\n\n_G.gpuProxy = loadfile(\"libs/dbgpu_api.lua\")({directDraw = false})\nlocal suc, err = xpcall(loadfile(\"game.lua\"), debug.traceback, true)\n\nif not suc then\n    print(err, debug.traceback())\nend\n\nshell.setWorkingDirectory(currentWorkingDir)",} 
--===== local functions =====--
function seperatePath(path) --Ripped from UT_v0.6.1
--seperates a data path ["./DIR/FILE.ENDING"] into the dir path ["./DIR/"], the file name ["FILE"], and the file ending [".ENDING" or nil]
  if string.sub(path, #path) == "/" then
    return path
  end
  
  local dir, fileName, fileEnd = "", "", nil
  local tmpLatest = ""
  for s in string.gmatch(tostring(path), "[^/]+") do
    tmpLatest = s
  end
  dir = string.sub(path, 0, #path -#tmpLatest)
  for s in string.gmatch(tostring(tmpLatest), "[^.]+") do
    fileName = fileName .. s
    tmpLatest = s
  end
  if fileName == tmpLatest then
    fileName = tmpLatest
  else
    fileEnd = "." .. tmpLatest
    fileName = string.sub(fileName, 0, #fileName - #fileEnd +1)
  end
  
  return dir, fileName, fileEnd
end

--===== prog start =====--
local fs = require("filesystem")
local shell = require("shell")
local serialization = require("serialization")

local args, opts = shell.parse(...)
local emptyBufferSpace = 10

if opts.h or #args == 0 then
  
  print("Usage: SETUP [OPTIONS]... [TARGET_DIR]...")
  print("  -h     Shows this text.")
  print("  -o       Overwrite the EXPORT_DIR.")
  
  return true
end

print(licenseNotice)

if not opts.o then
  if string.sub(args[1], 0, 1) == "/" and fs.exists(args[1]) then
    return false, "Folder exists already."
  elseif fs.exists(shell.getWorkingDirectory() .. args[1]) then
    return false, "Folder exists already."
  end
end

for i, s in pairs(data) do
  local path, file, ending = seperatePath(i)
  file = (file or "") .. (ending or "")
  if string.sub(args[1], 0, 1) == "/" then
    path = "/" .. args[1] .. "/" .. (path or "")
  else
    path = shell.getWorkingDirectory() .. "/" .. args[1] .. "/" .. (path or "")
  end
  
  print("Create file: " .. path .. file)
  
  fs.makeDirectory(path)
  if s ~= 0 then
    local f = io.open(path .. file, "w")
    for c = 1, #s, (f.bufferSize - emptyBufferSpace) +1 do
      f:write(string.sub(s, c, c + f.bufferSize - emptyBufferSpace))
      f:flush()
    end
    f:close()
  end
end
